
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import sys
import argparse
import logging
from send2trash import send2trash
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor

def parse_args():
    parser = argparse.ArgumentParser(description="Clean duplicate JPG/JPEG files if same-name main file exists")
    parser.add_argument("directory", nargs="?", default=".", help="Target directory (default: current directory)")
    parser.add_argument("--force", action="store_true", help="Permanently delete files (default: move to trash)")
    parser.add_argument("--dry-run", action="store_true", help="Dry run mode (preview only, no deletion)")
    parser.add_argument("--log", default=None, help="Log file path (default: autogenerated)")
    parser.add_argument("--threads", type=int, default=4, help="Number of concurrent threads")
    return parser.parse_args()

def find_jpg_candidates(target_dir):
    jpg_files = []
    for root, _, files in os.walk(target_dir):
        for file in files:
            if file.lower().endswith((".jpg", ".jpeg")):
                full_path = os.path.join(root, file)
                base_name = os.path.splitext(file)[0]
                jpg_files.append((full_path, base_name))
    return jpg_files

def should_delete(jpg_path, base_name):
    directory = os.path.dirname(jpg_path)
    for file in os.listdir(directory):
        name, ext = os.path.splitext(file)
        if name == base_name and ext.lower() not in [".jpg", ".jpeg"]:
            return os.path.join(directory, file)
    return None

def delete_file(path, force, dry_run):
    if dry_run:
        print(f"[DRY-RUN] Would delete: {path}")
        return
    try:
        if force:
            os.remove(path)
            print(f"[DELETED] Permanently deleted: {path}")
        else:
            send2trash(path)
            print(f"[TRASHED] Moved to trash: {path}")
    except Exception as e:
        print(f"[ERROR] Failed to delete {path}: {e}")

def setup_logger(log_path):
    logging.basicConfig(
        filename=log_path,
        level=logging.INFO,
        format="%(asctime)s - %(message)s",
    )
    return logging.getLogger(__name__)

def main():
    args = parse_args()
    log_file = args.log or f"clean_jpg_log_{Path(args.directory).name}.txt"
    logger = setup_logger(log_file)
    candidates = find_jpg_candidates(args.directory)
    tasks = []

    with ThreadPoolExecutor(max_workers=args.threads) as executor:
        for jpg_path, base_name in candidates:
            match = should_delete(jpg_path, base_name)
            if match:
                logger.info(f"Matched: {jpg_path} (main file: {match})")
                print(f"🔍 Match found: {jpg_path} -> main: {match}")
                tasks.append(executor.submit(delete_file, jpg_path, args.force, args.dry_run))
    
    print(f"✅ Completed. Log written to: {log_file}")

if __name__ == "__main__":
    main()
